// last menu of the project
// the programme creates four different periodic waveforms based on the standard mathematical formulas
// used in signal processing and electronics. 
// each waveform is generated by calculating its value at many points in time, samples.
// signal generator asks the user what waveform they want
// along with the amplitude, frequency and sample rate
// generates the waveform using math 
// optionally adds noise
// shows raw numerical values
// graphs it using ascii plot
// allows the user to save it as CSV file 
// its almost like a mini scope and waveform generator 
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include "funcs.h"
#include "menu6_signalgen.h"
//definition
#ifndef M_PI
#define M_PI 3.14159265358979323846 // got it from a University paper 
#endif

// function prototypes
static void generate_waveform(double *buffer, int N, int type, double A, double f, double fs, int noise);
static void ascii_plot(double *buffer, int N);
static void save_csv(double *buffer, int N, const char *filename);

// MAIN MENU
void menu_item_6(void)
{
    print_header("Advanced Signal Generator");
    printf("1. Sine wave\n");
    printf("2. Square wave\n");
    printf("3. Triangle wave\n");
    printf("4. Sawtooth wave\n");
    printf("5. Back to Main Menu\n\n");
    int choice;
    do {
        choice = read_int("Enter choice (1-5): ");
    } while (choice < 1 || choice > 5);
    if (choice == 5)
        return;
    
    // asks user for waveform parameters 
    // settings that control what the graph will look like 
    double A  = read_double("Enter amplitude (A): ");
    double f  = read_double("Enter frequency (Hz): ");
    double fs = read_double("Sample rate (samples/s): ");
    int N     = read_int("Number of samples: ");
    int noise_choice = read_int("Add noise? (1=yes, 0=no): ");
    int noise_flag = (noise_choice == 1);

    //allocate memory for waveform samples 
    double *buffer = malloc(sizeof(double) * N);
    if (!buffer) {
        printf("Memory allocation failed.\n");
        return;
    }
    //generates the actual waveform 
    generate_waveform(buffer, N, choice, A, f, fs, noise_flag);
    // print numeric samples 
    print_header("Waveform Samples");
    for (int i = 0; i < N; i++)
    printf("Sample %d: %.6f\n", i, buffer[i]);
    //draws ascii graph 
    print_header("ASCII Waveform Plot");
    ascii_plot(buffer, N);

    // CSV Save Option 
    // user can save data to a file such as excel 
    char ans[10];
    char filename[100];
    // asks user 
    printf("\nSave to CSV file? (y/n): ");
    fgets(ans, sizeof(ans), stdin);
    if (ans[0] == 'y' || ans[0] == 'Y')
    {
        printf("enter filename (e.g. wave.csv): ");
        fgets(filename, sizeof(filename), stdin);
        filename[strcspn(filename, "\r\n")] = '\0';

        save_csv(buffer, N, filename);
        printf("saved successfully!\n");
    }
    free(buffer);
}

// WAVEFORM GENERATOR 
static void generate_waveform(double *buffer, int N, int type,
                              double A, double f, double fs, int noise)
{
    // go through all N samples 
    for (int n = 0; n < N; n++)
    {
        // converts sample number into actual time 
        double t = (double)n / fs;
        // will store the sample value 
        double x;

        // switch selects waveform type 
        switch (type)
{
    // 1 SINE WAVE eee
    case 1:
    {
        // usual sine wave argument 
        double angle = 2 * M_PI * f * t;
        // calculates sin at that time 
        double s = sin(angle);
        // clamp values just in case floating point errors overshoot abit 
        if (s > 1.0) s = 1.0;    
        if (s < -1.0) s = -1.0;
        // apply amplitude given by user to make the wave seem taller 
        x = A * s;
    }
    break;

    // 2 SQUARE WAVE 
    case 2:
        // positive when sin is greater/equal to 0,negative otherwise 
        // in other words, if sine is positive, output +A, else output -A
        // this gives on and off square shape 
        x = (sin(2 * M_PI * f * t) >= 0) ? A : -A;
        break;

    // 3 TRIANGLE WAVE 
    case 3:
    {
        // counts cycle 
        double phase = f * t;
        // keeps only 0 to 1 part 
        double frac  = phase - floor(phase);

        //make a rampgoing from -A to +A
        double tri = 2*A * (2*frac - 1.0);

        //fold the ramp to form triangular shape 
        x = fabs(tri) - A;
    }
    break;

    // 4 SAWTOOH WAVE 
    case 4:
    {
        double phase = f * t;
        // 0 to 1 fraction 
        double frac  = phase - floor(phase);

        // a straight ramp from -A to +A
        x = (2 * A * frac) - A;
    }
    break;

    // if user inputs wrong type output zero 
    default:
        x = 0;
}

// this adds small random bumps to make it seem realistic 
// user chooses this by pressin 0 for no and 1 for yes 
        if (noise)
        {
            double nval = ((double)rand() / RAND_MAX)*0.1*A - 0.05*A;
            x += nval;
        }
        // saves sample in array 
        buffer[n] = x;
    }
}
// ASCII PLOT 
static void ascii_plot(double *buffer, int N)
{
    // numbers of text rows used to draw the wave 
    const int height = 20;

    //finds peak amplitude, min and max values, to scale the plot properly 
    double maxA = -1e9, minA = 1e9;
    for (int i = 0; i < N; i++)
    {
        if (buffer[i] > maxA) maxA = buffer[i];
        if (buffer[i] < minA) minA = buffer[i];
    }

    // amplitude used for normalisation so drawiing fits into the screen
    double A = fmax(fabs(maxA), fabs(minA));
    // avoid division by 0 if signal is too small
    if (A < 1e-6) A = 1.0;            

    // downsample so the graph doesnâ€™t stretch across the terminal  
    int step = (N > 120) ? N / 120 : 1;

    // prints stars row by row 
    for (int row = 0; row < height; row++)
    {
        for (int col = 0; col < N; col += step)
        {
            //normalise amplitude to range from 0 to 1 then map to row number 
            double norm = (buffer[col] + A) / (2 * A);
            int ypos = (int)(norm * (height - 1) + 0.5); 
            // flips vertically so that top is max and bottom is min
            ypos = height - 1 - ypos; 
            // place star if this row matches the waveform height 
            if (ypos == row)
                printf("*");
            else
                printf(" ");
        }
        printf("\n");
    }
}
// CSV export 
static void save_csv(double *buffer, int N, const char *filename)
{
    // opens file for writing 
    FILE *fp = fopen(filename, "w");
    // if file can't open, it will stop here 
    if (!fp)
    {
        printf("Error: could not open file.\n");
        return;
    }
    // adds header row for clarity 
    fprintf(fp, "index,value\n");
    // writes sample number and sample value on each row 
    for (int i = 0; i < N; i++)
        fprintf(fp, "%d,%.6f\n", i, buffer[i]);

    // closes file safely 
    fclose(fp);
}